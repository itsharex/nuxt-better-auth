---
title: Composables
description: API reference for client-side composables.
---

## useUserSession

The primary composable for accessing authentication state. Returns reactive user, session, and auth client.

```ts [pages/login.vue]
const { loggedIn, user, session, client, signIn, signOut } = useUserSession()
```

::field-group
  ::field{name="loggedIn" type="ComputedRef<boolean>"}
    `true` if the user is currently authenticated.
  ::
  ::field{name="user" type="Ref<AuthUser | null>"}
    The current user object, inferred from your config.
  ::
  ::field{name="session" type="Ref<AuthSession | null>"}
    The current session object.
  ::
  ::field{name="ready" type="ComputedRef<boolean>"}
    `true` when initial session resolution is complete (from SSR hydration or client fetch).
  ::
  ::field{name="client" type="AuthClient | null"}
    Direct access to the Better Auth client instance.
  ::
::

### Methods

#### `signIn`

Proxies Better Auth `signIn`.

```ts
await signIn.email({
  email: 'user@example.com',
  password: 'password'
})
```

### Promise Behavior

Methods like `signIn` return a promise that resolves when the **server responds**, not when local state updates.

```ts
// This awaits the server response
await client.signIn.email({ email, password })

// Local state updates asynchronously after
// Use onSuccess callback for actions that depend on updated state
await client.signIn.email(
  { email, password },
  { onSuccess: () => navigateTo('/dashboard') }
)
```

#### `signUp`

Proxies Better Auth `signUp` with the same `onSuccess` behavior as `signIn`.

```ts
await signUp.email({
  email: 'user@example.com',
  password: 'password'
})
```

#### `signOut`

Signs the user out and clears the local session state.

```ts
await signOut()
```

**Options**

```ts
await signOut({
  onSuccess: () => navigateTo('/'),
})
```

### `waitForSession()`

Waits for session state to be ready. Resolves when user is logged in or after 5 second timeout.

```ts
await waitForSession()
// Session is now ready (or timed out)
```

::tip
Use this when you need to ensure session state before proceeding. The function always resolves - it doesn't throw or return a value.
::

#### `fetchSession`

Manually triggers a session refresh. Useful if you've updated user data on the server via a side channel.

```ts
await fetchSession()
```

**Options**

```ts
await fetchSession({
  headers, // optional HeadersInit
  force: true, // disables Better Auth cookie cache for this fetch
})
```

#### `updateUser`

Updates the user on the server and optimistically patches local state. Local state reverts if the server call fails.

```ts
await updateUser({ name: 'New Name' })
```

::note
During SSR, `updateUser` only patches local state since no client is available.
::

::tip
**Reactivity**: `user` and `session` are global states using `useState`. Changes in one component are instantly reflected everywhere.
::

:read-more{to="/api/components" title="BetterAuthState component"}

## useUserSignIn

Returns a keyed action handle for `useUserSession().signIn.*`. Each method handle exposes template-friendly async state, similar to composables like `useFetch`.

```ts [pages/login.vue]
const { execute, data, status, error, errorMessage } = useUserSignIn('email')

await execute(
  { email, password, rememberMe },
  {
    onSuccess: () => navigateTo('/app'),
    onError: (ctx) => console.error(ctx.error),
  },
)

if (status.value === 'error') {
  console.error(errorMessage.value)
}
```

Use renaming to avoid collisions when you use multiple methods in the same scope:

```ts [pages/login.vue]
const {
  execute: loginWithEmail,
  status: statusEmail,
  error: errorEmail,
} = useUserSignIn('email')

const {
  execute: loginWithPasskey,
  status: statusPasskey,
  error: errorPasskey,
} = useUserSignIn('passkey')
```

Each method returns an action handle:

::field-group
  ::field{name="execute" type="(...args) => Promise<void>"}
    Calls the underlying Better Auth method and never throws.
  ::
  ::field{name="status" type="'idle' | 'pending' | 'success' | 'error'"}
    Current status of the latest `execute()` call.
  ::
  ::field{name="data" type="any | null"}
    Last successful result. Cleared on each new `execute()` and on errors.
  ::
  ::field{name="error" type="AuthActionError | null"}
    Normalized error for the latest call (cleared on new `execute()`).
  ::
  ::field{name="errorMessage" type="string | null"}
    Convenience computed string from `error?.message`.
  ::
::

::note
Each sign-in method has independent state. When you call `execute()` multiple times, only the latest call updates `status` and `error`.
::

### Error state and promise behavior

Use `status`, `data`, `error`, and `errorMessage` as your source of truth. The action handle always sets `status='error'` and populates normalized `error` when a sign-in attempt fails.

::note
Better Auth methods can signal failure by throwing or by resolving to a `{ error }` result. In both cases, the action handle updates `status` and `error`, and `await execute()` always resolves.
::

#### Recommended flow (`execute`)

```ts [pages/login.vue]
const { execute, data, status, errorMessage } = useUserSignIn('email')

await execute({ email, password })

if (status.value === 'error') {
  console.error(errorMessage.value)
}

if (status.value === 'success') {
  console.log(data.value)
}
```

::warning
`useUserSignIn` and `useUserSignUp` switched from map-style access (`useUserSignIn().email`) to keyed access (`useUserSignIn('email')`) in alpha.
`error` changed from `unknown | null` to `AuthActionError | null` in alpha.
`execute()` changed twice in alpha:
- old: `await execute()` could reject
- previous alpha: `await execute()` resolved `{ ok: true, data } | { ok: false, error }`
- new: `await execute()` resolves `void`, and you read `status` / `data` / `error`

If you relied on raw payloads, use `error.raw`.
::

## useUserSignUp

Same API as `useUserSignIn`, but wraps `useUserSession().signUp.*`.

```ts [pages/signup.vue]
const { execute, data, status, error, errorMessage } = useUserSignUp('email')

await execute(
  { email, password, name },
  {
    onSuccess: () => navigateTo('/welcome'),
    onError: (ctx) => console.error(ctx.error),
  },
)
```
