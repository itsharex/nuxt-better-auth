---
title: Composables
description: API reference for client-side composables.
---

## useUserSession

The primary composable for accessing authentication state. Returns reactive user, session, and auth client.

```ts [pages/login.vue]
const { loggedIn, user, session, client, signIn, signOut } = useUserSession()
```

::field-group
  ::field{name="loggedIn" type="ComputedRef<boolean>"}
    `true` if the user is currently authenticated.
  ::
  ::field{name="user" type="Ref<AuthUser | null>"}
    The current user object, inferred from your config.
  ::
  ::field{name="session" type="Ref<AuthSession | null>"}
    The current session object.
  ::
  ::field{name="ready" type="ComputedRef<boolean>"}
    `true` when initial session resolution is complete (from SSR hydration or client fetch).
  ::
  ::field{name="client" type="AuthClient | null"}
    Direct access to the Better Auth client instance.
  ::
::

### Methods

#### `signIn`

Proxies Better Auth `signIn`.

```ts
await signIn.email({
  email: 'user@example.com',
  password: 'password'
})
```

### Promise Behavior

Methods like `signIn` return a promise that resolves when the **server responds**, not when local state updates.

```ts
// This awaits the server response
await client.signIn.email({ email, password })

// Local state updates asynchronously after
// Use onSuccess callback for actions that depend on updated state
await client.signIn.email(
  { email, password },
  { onSuccess: () => navigateTo('/dashboard') }
)
```

#### `signUp`

Proxies Better Auth `signUp` with the same `onSuccess` behavior as `signIn`.

```ts
await signUp.email({
  email: 'user@example.com',
  password: 'password'
})
```

#### `signOut`

Signs the user out and clears the local session state.

```ts
await signOut()
```

**Options**

```ts
await signOut({
  onSuccess: () => navigateTo('/'),
})
```

### `waitForSession()`

Waits for session state to be ready. Resolves when user is logged in or after 5 second timeout.

```ts
await waitForSession()
// Session is now ready (or timed out)
```

::tip
Use this when you need to ensure session state before proceeding. The function always resolves - it doesn't throw or return a value.
::

#### `fetchSession`

Manually triggers a session refresh. Useful if you've updated user data on the server via a side channel.

```ts
await fetchSession()
```

**Options**

```ts
await fetchSession({
  headers, // optional HeadersInit
  force: true, // disables Better Auth cookie cache for this fetch
})
```

#### `updateUser`

Updates the user on the server and optimistically patches local state. Local state reverts if the server call fails.

```ts
await updateUser({ name: 'New Name' })
```

::note
During SSR, `updateUser` only patches local state since no client is available.
::

::tip
**Reactivity**: `user` and `session` are global states using `useState`. Changes in one component are instantly reflected everywhere.
::

:read-more{to="/api/components" title="BetterAuthState component"}

## useUserSignIn

Returns per-method action handles for `useUserSession().signIn.*`. Each method exposes template-friendly async state, similar to composables like `useFetch`.

```ts [pages/login.vue]
const { execute, pending, status, error } = useUserSignIn().email

await execute(
  { email, password, rememberMe },
  {
    onSuccess: () => navigateTo('/app'),
    onError: (ctx) => console.error(ctx.error),
  },
)
```

Use renaming to avoid collisions when you use multiple methods in the same scope:

```ts [pages/login.vue]
const {
  execute: loginWithEmail,
  pending: pendingEmail,
  status: statusEmail,
  error: errorEmail,
} = useUserSignIn().email

const {
  execute: loginWithPasskey,
  pending: pendingPasskey,
  status: statusPasskey,
  error: errorPasskey,
} = useUserSignIn().passkey
```

Each method returns an action handle:

::field-group
  ::field{name="execute" type="(...args) => Promise<any>"}
    Calls the underlying Better Auth method.
  ::
  ::field{name="status" type="'idle' | 'pending' | 'success' | 'error'"}
    Current status of the latest `execute()` call.
  ::
  ::field{name="pending" type="boolean"}
    `true` while the latest `execute()` call is running.
  ::
  ::field{name="error" type="unknown | null"}
    Error for the latest call (cleared on new `execute()`).
  ::
::

::note
Each sign-in method has independent state. When you call `execute()` multiple times, only the latest call updates `status` and `error`.
::

### Error state and promise behavior

Use `status` and `error` as your source of truth. The action handle always sets `status='error'` and populates `error` when a sign-in attempt fails.

::note
Better Auth methods can signal failure by throwing or by resolving to a `{ error }` result. In both cases, the action handle updates `status` and `error`. The only difference is whether `await execute()` rejects.
::

#### Show an error message (recommended)

This pattern works for both thrown errors and `{ error }` results:

```ts [pages/login.vue]
const { execute, status, error } = useUserSignIn().email

try {
  await execute({ email, password })
}
catch {
  // Ignore the thrown error here. Use the reactive error state below.
}

if (status.value === 'error') {
  console.error(error.value)
}
```

#### Use return values (when you need them)

If you rely on a methodâ€™s return value, you can still check for the Better Auth `{ error }` pattern:

```ts [pages/login.vue]
const { execute } = useUserSignIn().email

const result = await execute({ email, password })
if (result && typeof result === 'object' && 'error' in result && (result as any).error) {
  console.error((result as any).error)
}
```

## useUserSignUp

Same API as `useUserSignIn`, but wraps `useUserSession().signUp.*`.

```ts [pages/signup.vue]
const { execute, pending, status, error } = useUserSignUp().email

await execute(
  { email, password, name },
  {
    onSuccess: () => navigateTo('/welcome'),
    onError: (ctx) => console.error(ctx.error),
  },
)
```
