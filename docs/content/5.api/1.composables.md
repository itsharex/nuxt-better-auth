---
title: Composables
description: API reference for client-side composables.
---

## useUserSession

The primary composable for accessing authentication state. Returns reactive user, session, and auth client.

```ts [pages/login.vue]
const { loggedIn, user, session, client, signIn, signOut } = useUserSession()
```

::field-group
  ::field{name="loggedIn" type="ComputedRef<boolean>"}
    `true` if the user is currently authenticated.
  ::
  ::field{name="user" type="Ref<AuthUser | null>"}
    The current user object, inferred from your config.
  ::
  ::field{name="session" type="Ref<AuthSession | null>"}
    The current session object.
  ::
  ::field{name="ready" type="ComputedRef<boolean>"}
    `true` when initial session resolution is complete (from SSR hydration or client fetch).
  ::
  ::field{name="client" type="AuthClient | null"}
    Direct access to the Better Auth client instance.
  ::
::

### Methods

#### `signIn`

Proxies Better Auth `signIn`.

```ts
await signIn.email({
  email: 'user@example.com',
  password: 'password'
})
```

### Promise Behavior

Methods like `signIn` return a promise that resolves when the **server responds**, not when local state updates.

```ts
// This awaits the server response
await client.signIn.email({ email, password })

// Local state updates asynchronously after
// Use onSuccess callback for actions that depend on updated state
await client.signIn.email(
  { email, password },
  { onSuccess: () => navigateTo('/dashboard') }
)
```

If no `onSuccess` callback is provided, `signIn` will:
- navigate to `route.query.redirect` (or custom `auth.redirectQueryKey`) when it is a local path
- otherwise fallback to `auth.redirects.authenticated` when configured and an authenticated session is established
- otherwise no automatic navigation

```ts
await signIn.email({ email, password }) // redirects to safe `?redirect=...` or auth.redirects.authenticated
```

#### `signUp`

Proxies Better Auth `signUp` with the same `onSuccess` behavior as `signIn`.

```ts
await signUp.email({
  email: 'user@example.com',
  password: 'password'
})
```

Like `signIn`, if no callback is provided, `signUp` follows the same redirect precedence:
query redirect > `auth.redirects.authenticated` (only when authenticated) > no auto-redirect.

#### `signOut`

Signs the user out and clears the local session state.

```ts
await signOut()
```

If `auth.redirects.logout` is configured, `signOut()` will navigate there automatically (client-side), unless you provide `onSuccess`.

**Options**

```ts
await signOut({
  onSuccess: () => navigateTo('/'),
})
```

### `waitForSession()`

Waits for session state to be ready. Resolves when user is logged in or after 5 second timeout.

```ts
await waitForSession()
// Session is now ready (or timed out)
```

::tip
Use this when you need to ensure session state before proceeding. The function always resolves - it doesn't throw or return a value.
::

#### `fetchSession`

Manually triggers a session refresh. Useful if you've updated user data on the server via a side channel.

```ts
await fetchSession()
```

**Options**

```ts
await fetchSession({
  headers, // optional HeadersInit
  force: true, // disables Better Auth cookie cache for this fetch
})
```

#### `updateUser`

Updates the user on the server and optimistically patches local state. Local state reverts if the server call fails.

```ts
await updateUser({ name: 'New Name' })
```

::note
During SSR, `updateUser` only patches local state since no client is available.
::

::tip
**Reactivity**: `user` and `session` are global states using `useState`. Changes in one component are instantly reflected everywhere.
::

:read-more{to="/api/components" title="BetterAuthState component"}

## useSignIn

Returns a keyed action handle for `useUserSession().signIn.*`. Each method handle exposes template-friendly async state, similar to composables like `useFetch`.

```ts [pages/login.vue]
const { execute, data, status, error } = useSignIn('email')

await execute(
  { email, password, rememberMe },
  {
    onSuccess: () => navigateTo('/app'),
    onError: (ctx) => console.error(ctx.error),
  },
)

if (status.value === 'error') {
  console.error(error.value?.message)
}
```

For OAuth sign-in with `useSignIn`, pass a configured provider id directly:

```ts [pages/login.vue]
await useSignIn('github').execute({ callbackURL: '/app' })
```

Provider keys are inferred from `server/auth.config.ts` `socialProviders` keys.

Use renaming to avoid collisions when you use multiple methods in the same scope:

```ts [pages/login.vue]
const {
  execute: loginWithEmail,
  status: statusEmail,
  error: errorEmail,
} = useSignIn('email')

const {
  execute: loginWithPasskey,
  status: statusPasskey,
  error: errorPasskey,
} = useSignIn('passkey')
```

Each method returns an action handle:

::field-group
  ::field{name="execute" type="(...args) => Promise<void>"}
    Calls the underlying Better Auth method and never throws.
  ::
  ::field{name="status" type="'idle' | 'pending' | 'success' | 'error'"}
    Current status of the latest `execute()` call.
  ::
  ::field{name="data" type="any | null"}
    Last successful result. Cleared on each new `execute()` and on errors.
  ::
  ::field{name="error" type="AuthActionError | null"}
    Normalized error for the latest call (cleared on new `execute()`).
  ::
::

::note
Each sign-in method has independent state. When you call `execute()` multiple times, only the latest call updates `status` and `error`.
::

### Error state and promise behavior

Use `status`, `data`, and `error` as your source of truth. The action handle always sets `status='error'` and populates normalized `error` when a sign-in attempt fails.

::note
Better Auth methods can signal failure by throwing or by resolving to a `{ error }` result. In both cases, the action handle updates `status` and `error`, and `await execute()` always resolves.
::

#### Recommended flow (`execute`)

```ts [pages/login.vue]
const { execute, data, status, error } = useSignIn('email')

await execute({ email, password })

if (status.value === 'error') {
  console.error(error.value?.message)
}

if (status.value === 'success') {
  console.log(data.value)
}
```

::warning
`useUserSignIn` and `useUserSignUp` were renamed to `useSignIn` and `useSignUp` in alpha.
The API switched from map-style access (`useUserSignIn().email`) to keyed access (`useSignIn('email')`) in alpha.
`error` changed from `unknown | null` to `AuthActionError | null` in alpha.
The message alias field was removed in alpha. Use `error.value?.message`.
`execute()` changed twice in alpha:
- old: `await execute()` could reject
- previous alpha: `await execute()` resolved `{ ok: true, data } | { ok: false, error }`
- new: `await execute()` resolves `void`, and you read `status` / `data` / `error`

If you relied on raw payloads, use `error.raw`.
::

## useSignUp

Same API as `useSignIn`, but wraps `useUserSession().signUp.*`.

```ts [pages/signup.vue]
const { execute, data, status, error } = useSignUp('email')

await execute(
  { email, password, name },
  {
    onSuccess: () => navigateTo('/welcome'),
    onError: (ctx) => console.error(ctx.error),
  },
)
```
